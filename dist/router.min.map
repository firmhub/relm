{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6****","webpack:///router.min.js","webpack:///./~/lodash/map.js","webpack:///./~/lodash/startsWith.js","webpack:///./~/lodash/tail.js","webpack:///./~/path-to-regexp/index.js","webpack:///./~/lodash/_baseMap.js","webpack:///./~/lodash/_baseSlice.js","webpack:///./~/path-to-regexp/~/isarray/index.js","webpack:///./src/router.js"],"names":["root","factory","exports","module","define","amd","this","webpackJsonprelm__name_","142","__webpack_require__","map","collection","iteratee","func","isArray","arrayMap","baseMap","baseIteratee","144","startsWith","string","target","position","toString","baseClamp","toInteger","length","baseToString","slice","145","tail","array","baseSlice","147","parse","str","res","tokens","key","index","path","PATH_REGEXP","exec","m","escaped","offset","next","prefix","name","capture","group","modifier","asterisk","push","partial","repeat","optional","delimiter","pattern","escapeGroup","substr","compile","tokensToFunction","encodeURIComponentPretty","encodeURI","replace","c","charCodeAt","toUpperCase","encodeAsterisk","matches","Array","i","RegExp","obj","opts","data","options","encode","pretty","encodeURIComponent","token","segment","value","TypeError","isarray","JSON","stringify","j","test","escapeString","attachKeys","re","keys","flags","sensitive","regexpToRegexp","groups","source","match","arrayToRegexp","parts","pathToRegexp","regexp","join","stringToRegexp","tokensToRegExp","strict","end","route","lastToken","endsWithSlash","187","result","isArrayLike","baseEach","194","start","277","arr","Object","prototype","call","313","routeParser","__WEBPACK_IMPORTED_MODULE_7_path_to_regexp___default","__WEBPACK_IMPORTED_MODULE_5_lodash_reduce___default","__WEBPACK_IMPORTED_MODULE_4_lodash_tail___default","routeMapper","definitions","parsers","__WEBPACK_IMPORTED_MODULE_3_lodash_map___default","def","parser","params","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","done","err","return","router","routeDefinitions","Router","html","props","children","components","url","prefixedUrl","__WEBPACK_IMPORTED_MODULE_2_lodash_startsWith___default","parseRoute","child","childProps","__WEBPACK_IMPORTED_MODULE_1_lodash_assign___default","__WEBPACK_IMPORTED_MODULE_0_lodash_mapValues___default","__WEBPACK_IMPORTED_MODULE_0_lodash_mapValues__","n","__WEBPACK_IMPORTED_MODULE_1_lodash_assign__","__WEBPACK_IMPORTED_MODULE_2_lodash_startsWith__","__WEBPACK_IMPORTED_MODULE_3_lodash_map__","__WEBPACK_IMPORTED_MODULE_4_lodash_tail__","__WEBPACK_IMPORTED_MODULE_5_lodash_reduce__","__WEBPACK_IMPORTED_MODULE_6_tcomb__","__WEBPACK_IMPORTED_MODULE_7_path_to_regexp__","d","internals"],"mappings":"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","file":"router.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"router\"] = factory();\n\telse\n\t\troot[\"relm\"] = root[\"relm\"] || {}, root[\"relm\"][\"router\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"router\"] = factory();\n\telse\n\t\troot[\"relm\"] = root[\"relm\"] || {}, root[\"relm\"][\"router\"] = factory();\n})(this, function() {\nreturn webpackJsonprelm__name_([4],{\n\n/***/ 142:\n/***/ function(module, exports, __webpack_require__) {\n\nvar arrayMap = __webpack_require__(88),\n    baseIteratee = __webpack_require__(38),\n    baseMap = __webpack_require__(187),\n    isArray = __webpack_require__(1);\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n\n\n/***/ },\n\n/***/ 144:\n/***/ function(module, exports, __webpack_require__) {\n\nvar baseClamp = __webpack_require__(89),\n    baseToString = __webpack_require__(65),\n    toInteger = __webpack_require__(73),\n    toString = __webpack_require__(74);\n\n/**\n * Checks if `string` starts with the given target string.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {string} [target] The string to search for.\n * @param {number} [position=0] The position to search from.\n * @returns {boolean} Returns `true` if `string` starts with `target`,\n *  else `false`.\n * @example\n *\n * _.startsWith('abc', 'a');\n * // => true\n *\n * _.startsWith('abc', 'b');\n * // => false\n *\n * _.startsWith('abc', 'b', 1);\n * // => true\n */\nfunction startsWith(string, target, position) {\n  string = toString(string);\n  position = baseClamp(toInteger(position), 0, string.length);\n  target = baseToString(target);\n  return string.slice(position, position + target.length) == target;\n}\n\nmodule.exports = startsWith;\n\n\n/***/ },\n\n/***/ 145:\n/***/ function(module, exports, __webpack_require__) {\n\nvar baseSlice = __webpack_require__(194);\n\n/**\n * Gets all but the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.tail([1, 2, 3]);\n * // => [2, 3]\n */\nfunction tail(array) {\n  var length = array ? array.length : 0;\n  return length ? baseSlice(array, 1, length) : [];\n}\n\nmodule.exports = tail;\n\n\n/***/ },\n\n/***/ 147:\n/***/ function(module, exports, __webpack_require__) {\n\nvar isarray = __webpack_require__(277)\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string} str\n * @return {!Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys)\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\n\n/***/ },\n\n/***/ 187:\n/***/ function(module, exports, __webpack_require__) {\n\nvar baseEach = __webpack_require__(63),\n    isArrayLike = __webpack_require__(21);\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n\n\n/***/ },\n\n/***/ 194:\n/***/ function(module, exports) {\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n\n\n/***/ },\n\n/***/ 277:\n/***/ function(module, exports) {\n\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n/***/ },\n\n/***/ 313:\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_mapValues__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_mapValues___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_mapValues__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_assign__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash_assign__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_startsWith__ = __webpack_require__(144);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_startsWith___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash_startsWith__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash_map__ = __webpack_require__(142);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash_map__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash_tail__ = __webpack_require__(145);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash_tail___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash_tail__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_reduce__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_reduce___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash_reduce__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_tcomb__ = __webpack_require__(80);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_tcomb___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_tcomb__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_path_to_regexp__ = __webpack_require__(147);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_path_to_regexp___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_path_to_regexp__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__types__ = __webpack_require__(53);\n/* harmony export */ exports[\"default\"] = router;\n/* harmony export */ __webpack_require__.d(exports, \"internals\", function() { return internals; });\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Creates a single route parser given a path (ex /some/:named/:path*)\n * The return exec method returns an object of all named parameters\n *\n * Returned exec() method takes a url string and returns an object with route params\n *\n * @param {Regex} path\n * @returns {Object} with exec() method to match against strings\n */\nfunction routeParser(path) {\n  var keys = [];\n  var re = __WEBPACK_IMPORTED_MODULE_7_path_to_regexp___default()(path, keys);\n\n  return {\n    exec: function exec(str) {\n      var matches = re.exec(str);\n      if (!matches) return null;\n\n      return __WEBPACK_IMPORTED_MODULE_5_lodash_reduce___default()(__WEBPACK_IMPORTED_MODULE_4_lodash_tail___default()(matches), function (obj, match, i) {\n        if (!match) return obj;\n\n        obj[keys[i].name] = match;\n        return obj;\n      }, {});\n    }\n  };\n}\n\n/**\n * Takes multiple route definitions and returns a single\n * parse function to match against all the definitions\n * Example of a definition: {\n *   SomeRoute: [Component, '/some/:named/:path*']\n * }\n * @param {Object} definitions\n * @returns {Function} parser\n */\nfunction routeMapper(definitions) {\n  var parsers = __WEBPACK_IMPORTED_MODULE_3_lodash_map___default()(definitions, function definitionsToParser(def, name) {\n    var parser = routeParser(def[1]);\n    return function exec(str) {\n      var params = parser.exec(str);\n      if (!params) return null;\n      return { name: name, params: params };\n    };\n  });\n\n  return function parser(str) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = parsers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var parse = _step.value;\n\n        var result = parse(str);\n        if (result) return result;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return null;\n  };\n}\n\n/**\n * Main router function; takes a set of route definitions and\n * returns a relm component which utilizies those routes\n * Example of a definition: {\n *   SomeRoute: [Component, '/some/:named/:path*']\n * }\n * @param {Object} routeDefinitions\n * @returns {Object} component\n */\nfunction router(routeDefinitions) {\n  if (false) {\n    (function () {\n      var Path = t.refinement(t.String, function (x) {\n        return _startsWith('/', x);\n      }, 'Path');\n\n      var RouteWithoutOptions = t.tuple([Component, Path], '-');\n      var RouteWithOptions = t.tuple([Component, Path, t.Boolean], '-');\n\n      var RouteDefinition = t.union([RouteWithoutOptions, RouteWithOptions], 'Route');\n\n      RouteDefinition.dispatch = function (x) {\n        return x.length > 2 ? RouteWithOptions : RouteWithoutOptions;\n      };\n\n      t.dict(t.String, RouteDefinition, 'Routes')(routeDefinitions);\n    })();\n  }\n\n  var parseRoute = routeMapper(routeDefinitions);\n\n  function Router(html, params) {\n    var props = params.props;\n    var children = params.children;\n    var components = params.components;\n\n\n    var url = props.url || '';\n    var prefixedUrl = __WEBPACK_IMPORTED_MODULE_2_lodash_startsWith___default()(url, '/') ? url : '/' + url;\n    var route = parseRoute(prefixedUrl);\n    if (!route) return null;\n\n    var child = components[route.name];\n    var childProps = __WEBPACK_IMPORTED_MODULE_1_lodash_assign___default()(props, route.params);\n\n    return child(childProps, children);\n  }\n\n  Router.components = __WEBPACK_IMPORTED_MODULE_0_lodash_mapValues___default()(routeDefinitions, function (def) {\n    return def[0];\n  });\n\n  return Router;\n}\n\nvar internals = {\n  routeParser: routeParser,\n  routeMapper: routeMapper\n};\n\n/***/ }\n\n},[313])\n});\n;\n\n\n// WEBPACK FOOTER //\n// router.min.js","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    isArray = require('./isArray');\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/map.js\n// module id = 142\n// module chunks = 4","var baseClamp = require('./_baseClamp'),\n    baseToString = require('./_baseToString'),\n    toInteger = require('./toInteger'),\n    toString = require('./toString');\n\n/**\n * Checks if `string` starts with the given target string.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {string} [target] The string to search for.\n * @param {number} [position=0] The position to search from.\n * @returns {boolean} Returns `true` if `string` starts with `target`,\n *  else `false`.\n * @example\n *\n * _.startsWith('abc', 'a');\n * // => true\n *\n * _.startsWith('abc', 'b');\n * // => false\n *\n * _.startsWith('abc', 'b', 1);\n * // => true\n */\nfunction startsWith(string, target, position) {\n  string = toString(string);\n  position = baseClamp(toInteger(position), 0, string.length);\n  target = baseToString(target);\n  return string.slice(position, position + target.length) == target;\n}\n\nmodule.exports = startsWith;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/startsWith.js\n// module id = 144\n// module chunks = 4","var baseSlice = require('./_baseSlice');\n\n/**\n * Gets all but the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.tail([1, 2, 3]);\n * // => [2, 3]\n */\nfunction tail(array) {\n  var length = array ? array.length : 0;\n  return length ? baseSlice(array, 1, length) : [];\n}\n\nmodule.exports = tail;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/tail.js\n// module id = 145\n// module chunks = 4","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string} str\n * @return {!Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys)\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/path-to-regexp/index.js\n// module id = 147\n// module chunks = 4","var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseMap.js\n// module id = 187\n// module chunks = 4","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseSlice.js\n// module id = 194\n// module chunks = 4","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/path-to-regexp/~/isarray/index.js\n// module id = 277\n// module chunks = 4","import _ from 'lodash';\nimport t from 'tcomb';\nimport pathToRegexp from 'path-to-regexp';\n\nimport { Component } from './types';\n\n/**\n * Creates a single route parser given a path (ex /some/:named/:path*)\n * The return exec method returns an object of all named parameters\n *\n * Returned exec() method takes a url string and returns an object with route params\n *\n * @param {Regex} path\n * @returns {Object} with exec() method to match against strings\n */\nfunction routeParser (path) {\n  const keys = [];\n  const re = pathToRegexp(path, keys);\n\n  return {\n    exec (str) {\n      const matches = re.exec(str);\n      if (!matches) return null;\n\n      return _.reduce(_.tail(matches), (obj, match, i) => {\n        if (!match) return obj;\n\n        obj[keys[i].name] = match;\n        return obj;\n      }, {});\n    }\n  };\n}\n\n/**\n * Takes multiple route definitions and returns a single\n * parse function to match against all the definitions\n * Example of a definition: {\n *   SomeRoute: [Component, '/some/:named/:path*']\n * }\n * @param {Object} definitions\n * @returns {Function} parser\n */\nfunction routeMapper (definitions) {\n  const parsers = _.map(definitions, function definitionsToParser (def, name) {\n    const parser = routeParser(def[1]);\n    return function exec (str) {\n      const params = parser.exec(str);\n      if (!params) return null;\n      return { name, params };\n    };\n  });\n\n  return function parser (str) {\n    for (const parse of parsers) {\n      const result = parse(str);\n      if (result) return result;\n    }\n    return null;\n  };\n}\n\n/**\n * Main router function; takes a set of route definitions and\n * returns a relm component which utilizies those routes\n * Example of a definition: {\n *   SomeRoute: [Component, '/some/:named/:path*']\n * }\n * @param {Object} routeDefinitions\n * @returns {Object} component\n */\nexport default function router (routeDefinitions) {\n  if (process.env.NODE_ENV !== 'production') {\n    const Path = t.refinement(t.String, x => _.startsWith('/', x), 'Path');\n\n    const RouteWithoutOptions = t.tuple([Component, Path], '-');\n    const RouteWithOptions = t.tuple([Component, Path, t.Boolean], '-');\n\n    const RouteDefinition = t.union([\n      RouteWithoutOptions,\n      RouteWithOptions\n    ], 'Route');\n\n    RouteDefinition.dispatch = x => (x.length > 2 ? RouteWithOptions : RouteWithoutOptions);\n\n    t.dict(t.String, RouteDefinition, 'Routes')(routeDefinitions);\n  }\n\n  const parseRoute = routeMapper(routeDefinitions);\n\n  function Router (html, params) {\n    const { props, children, components } = params;\n\n    const url = props.url || '';\n    const prefixedUrl = _.startsWith(url, '/') ? url : `/${url}`;\n    const route = parseRoute(prefixedUrl);\n    if (!route) return null;\n\n    const child = components[route.name];\n    const childProps = _.assign(props, route.params);\n\n    return child(childProps, children);\n  }\n\n  Router.components = _.mapValues(routeDefinitions, def => def[0]);\n\n  return Router;\n}\n\nexport const internals = {\n  routeParser,\n  routeMapper,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/router.js"],"sourceRoot":""}