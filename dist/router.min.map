{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///router.min.js","webpack:///./~/lodash/_baseMap.js","webpack:///./~/lodash/_baseReduce.js","webpack:///./~/lodash/_baseSlice.js","webpack:///./~/lodash/toFinite.js","webpack:///./~/lodash/toInteger.js","webpack:///./~/lodash/toNumber.js","webpack:///./~/path-to-regexp/~/isarray/index.js","webpack:///./src/router.js","webpack:///./~/lodash/map.js","webpack:///./~/lodash/reduce.js","webpack:///./~/lodash/startsWith.js","webpack:///./~/lodash/tail.js","webpack:///./~/path-to-regexp/index.js","webpack:///./~/lodash/_arrayMap.js","webpack:///./~/lodash/_arrayReduce.js","webpack:///./~/lodash/_baseClamp.js"],"names":["root","factory","exports","module","define","amd","this","webpackJsonprelm__name_","105","__webpack_require__","baseMap","collection","iteratee","index","result","isArrayLike","Array","length","baseEach","value","key","110","baseReduce","accumulator","initAccum","eachFunc","112","baseSlice","array","start","end","166","toFinite","toNumber","INFINITY","sign","MAX_INTEGER","167","toInteger","remainder","168","isSymbol","NAN","isObject","other","valueOf","replace","reTrim","isBinary","reIsBinary","test","reIsOctal","freeParseInt","slice","reIsBadHex","parseInt","169","isArray","arr","Object","prototype","toString","call","196","routeParser","path","keys","re","__WEBPACK_IMPORTED_MODULE_7_path_to_regexp___default","exec","str","matches","__WEBPACK_IMPORTED_MODULE_5_lodash_reduce___default","__WEBPACK_IMPORTED_MODULE_4_lodash_tail___default","obj","match","i","name","routeMapper","definitions","parsers","__WEBPACK_IMPORTED_MODULE_3_lodash_map___default","def","parser","params","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","parse","err","return","router","routeDefinitions","Router","html","props","children","components","url","prefixedUrl","__WEBPACK_IMPORTED_MODULE_2_lodash_startsWith___default","route","parseRoute","child","childProps","__WEBPACK_IMPORTED_MODULE_1_lodash_assign___default","__WEBPACK_IMPORTED_MODULE_0_lodash_mapValues___default","__WEBPACK_IMPORTED_MODULE_0_lodash_mapValues__","n","__WEBPACK_IMPORTED_MODULE_1_lodash_assign__","__WEBPACK_IMPORTED_MODULE_2_lodash_startsWith__","__WEBPACK_IMPORTED_MODULE_3_lodash_map__","__WEBPACK_IMPORTED_MODULE_4_lodash_tail__","__WEBPACK_IMPORTED_MODULE_5_lodash_reduce__","__WEBPACK_IMPORTED_MODULE_6_tcomb__","__WEBPACK_IMPORTED_MODULE_7_path_to_regexp__","d","internals","78","map","func","arrayMap","baseIteratee","79","reduce","arrayReduce","arguments","80","startsWith","string","target","position","baseClamp","baseToString","81","tail","82","res","tokens","PATH_REGEXP","m","escaped","offset","prefix","capture","group","modifier","asterisk","push","partial","repeat","optional","delimiter","pattern","escapeGroup","substr","compile","tokensToFunction","encodeURIComponentPretty","encodeURI","c","charCodeAt","toUpperCase","encodeAsterisk","RegExp","opts","data","options","encode","pretty","encodeURIComponent","token","segment","TypeError","isarray","JSON","stringify","j","escapeString","attachKeys","flags","sensitive","regexpToRegexp","groups","source","arrayToRegexp","parts","pathToRegexp","regexp","join","stringToRegexp","tokensToRegExp","strict","lastToken","endsWithSlash","93","94","96","number","lower","upper"],"mappings":"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","file":"router.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"router\"] = factory();\n\telse\n\t\troot[\"relm\"] = root[\"relm\"] || {}, root[\"relm\"][\"router\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"router\"] = factory();\n\telse\n\t\troot[\"relm\"] = root[\"relm\"] || {}, root[\"relm\"][\"router\"] = factory();\n})(this, function() {\nreturn webpackJsonprelm__name_([0],{\n\n/***/ 105:\n/***/ function(module, exports, __webpack_require__) {\n\nvar baseEach = __webpack_require__(38),\n    isArrayLike = __webpack_require__(15);\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n\n\n/***/ },\n\n/***/ 110:\n/***/ function(module, exports) {\n\n/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initAccum\n      ? (initAccum = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseReduce;\n\n\n/***/ },\n\n/***/ 112:\n/***/ function(module, exports) {\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n\n\n/***/ },\n\n/***/ 166:\n/***/ function(module, exports, __webpack_require__) {\n\nvar toNumber = __webpack_require__(168);\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n\n\n/***/ },\n\n/***/ 167:\n/***/ function(module, exports, __webpack_require__) {\n\nvar toFinite = __webpack_require__(166);\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n\n\n/***/ },\n\n/***/ 168:\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(16),\n    isSymbol = __webpack_require__(28);\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n\n\n/***/ },\n\n/***/ 169:\n/***/ function(module, exports) {\n\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n/***/ },\n\n/***/ 196:\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_mapValues__ = __webpack_require__(35);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_mapValues___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_mapValues__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_assign__ = __webpack_require__(34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash_assign__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_startsWith__ = __webpack_require__(80);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_startsWith___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash_startsWith__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash_map__ = __webpack_require__(78);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash_map__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash_tail__ = __webpack_require__(81);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash_tail___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash_tail__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_reduce__ = __webpack_require__(79);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_reduce___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash_reduce__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_tcomb__ = __webpack_require__(47);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_tcomb___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_tcomb__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_path_to_regexp__ = __webpack_require__(82);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_path_to_regexp___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_path_to_regexp__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__types__ = __webpack_require__(33);\n/* harmony export */ exports[\"default\"] = router;\n/* harmony export */ __webpack_require__.d(exports, \"internals\", function() { return internals; });\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Creates a single route parser given a path (ex /some/:named/:path*)\n * The return exec method returns an object of all named parameters\n *\n * Returned exec() method takes a url string and returns an object with route params\n *\n * @param {Regex} path\n * @returns {Object} with exec() method to match against strings\n */\nfunction routeParser(path) {\n  var keys = [];\n  var re = __WEBPACK_IMPORTED_MODULE_7_path_to_regexp___default()(path, keys);\n\n  return {\n    exec: function exec(str) {\n      var matches = re.exec(str);\n      if (!matches) return null;\n\n      return __WEBPACK_IMPORTED_MODULE_5_lodash_reduce___default()(__WEBPACK_IMPORTED_MODULE_4_lodash_tail___default()(matches), function (obj, match, i) {\n        if (!match) return obj;\n\n        obj[keys[i].name] = match;\n        return obj;\n      }, {});\n    }\n  };\n}\n\n/**\n * Takes multiple route definitions and returns a single\n * parse function to match against all the definitions\n * Example of a definition: {\n *   SomeRoute: [Component, '/some/:named/:path*']\n * }\n * @param {Object} definitions\n * @returns {Function} parser\n */\nfunction routeMapper(definitions) {\n  var parsers = __WEBPACK_IMPORTED_MODULE_3_lodash_map___default()(definitions, function definitionsToParser(def, name) {\n    var parser = routeParser(def[1]);\n    return function exec(str) {\n      var params = parser.exec(str);\n      if (!params) return null;\n      return { name: name, params: params };\n    };\n  });\n\n  return function parser(str) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = parsers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var parse = _step.value;\n\n        var result = parse(str);\n        if (result) return result;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return null;\n  };\n}\n\n/**\n * Main router function; takes a set of route definitions and\n * returns a relm component which utilizies those routes\n * Example of a definition: {\n *   SomeRoute: [Component, '/some/:named/:path*']\n * }\n * @param {Object} routeDefinitions\n * @returns {Object} component\n */\nfunction router(routeDefinitions) {\n  if (false) {\n    (function () {\n      var Path = t.refinement(t.String, function (x) {\n        return _startsWith('/', x);\n      }, 'Path');\n\n      var RouteWithoutOptions = t.tuple([Component, Path], '-');\n      var RouteWithOptions = t.tuple([Component, Path, t.Boolean], '-');\n\n      var RouteDefinition = t.union([RouteWithoutOptions, RouteWithOptions], 'Route');\n\n      RouteDefinition.dispatch = function (x) {\n        return x.length > 2 ? RouteWithOptions : RouteWithoutOptions;\n      };\n\n      t.dict(t.String, RouteDefinition, 'Routes')(routeDefinitions);\n    })();\n  }\n\n  var parseRoute = routeMapper(routeDefinitions);\n\n  function Router(html, params) {\n    var props = params.props;\n    var children = params.children;\n    var components = params.components;\n\n\n    var url = props.url || '';\n    var prefixedUrl = __WEBPACK_IMPORTED_MODULE_2_lodash_startsWith___default()(url, '/') ? url : '/' + url;\n    var route = parseRoute(prefixedUrl);\n    if (!route) return null;\n\n    var child = components[route.name];\n    var childProps = __WEBPACK_IMPORTED_MODULE_1_lodash_assign___default()(props, route.params);\n\n    return child(childProps, children);\n  }\n\n  Router.components = __WEBPACK_IMPORTED_MODULE_0_lodash_mapValues___default()(routeDefinitions, function (def) {\n    return def[0];\n  });\n\n  return Router;\n}\n\nvar internals = {\n  routeParser: routeParser,\n  routeMapper: routeMapper\n};\n\n/***/ },\n\n/***/ 78:\n/***/ function(module, exports, __webpack_require__) {\n\nvar arrayMap = __webpack_require__(93),\n    baseIteratee = __webpack_require__(21),\n    baseMap = __webpack_require__(105),\n    isArray = __webpack_require__(6);\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n\n\n/***/ },\n\n/***/ 79:\n/***/ function(module, exports, __webpack_require__) {\n\nvar arrayReduce = __webpack_require__(94),\n    baseEach = __webpack_require__(38),\n    baseIteratee = __webpack_require__(21),\n    baseReduce = __webpack_require__(110),\n    isArray = __webpack_require__(6);\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3;\n\n  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n}\n\nmodule.exports = reduce;\n\n\n/***/ },\n\n/***/ 80:\n/***/ function(module, exports, __webpack_require__) {\n\nvar baseClamp = __webpack_require__(96),\n    baseToString = __webpack_require__(54),\n    toInteger = __webpack_require__(167),\n    toString = __webpack_require__(65);\n\n/**\n * Checks if `string` starts with the given target string.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {string} [target] The string to search for.\n * @param {number} [position=0] The position to search from.\n * @returns {boolean} Returns `true` if `string` starts with `target`,\n *  else `false`.\n * @example\n *\n * _.startsWith('abc', 'a');\n * // => true\n *\n * _.startsWith('abc', 'b');\n * // => false\n *\n * _.startsWith('abc', 'b', 1);\n * // => true\n */\nfunction startsWith(string, target, position) {\n  string = toString(string);\n  position = baseClamp(toInteger(position), 0, string.length);\n  target = baseToString(target);\n  return string.slice(position, position + target.length) == target;\n}\n\nmodule.exports = startsWith;\n\n\n/***/ },\n\n/***/ 81:\n/***/ function(module, exports, __webpack_require__) {\n\nvar baseSlice = __webpack_require__(112);\n\n/**\n * Gets all but the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.tail([1, 2, 3]);\n * // => [2, 3]\n */\nfunction tail(array) {\n  var length = array ? array.length : 0;\n  return length ? baseSlice(array, 1, length) : [];\n}\n\nmodule.exports = tail;\n\n\n/***/ },\n\n/***/ 82:\n/***/ function(module, exports, __webpack_require__) {\n\nvar isarray = __webpack_require__(169)\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string} str\n * @return {!Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys)\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\n\n/***/ },\n\n/***/ 93:\n/***/ function(module, exports) {\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n\n\n/***/ },\n\n/***/ 94:\n/***/ function(module, exports) {\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n\n\n/***/ },\n\n/***/ 96:\n/***/ function(module, exports) {\n\n/**\n * The base implementation of `_.clamp` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\n\nmodule.exports = baseClamp;\n\n\n/***/ }\n\n},[196])\n});\n;\n\n\n// WEBPACK FOOTER //\n// router.min.js","var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseMap.js\n// module id = 105\n// module chunks = 0","/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initAccum\n      ? (initAccum = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseReduce;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseReduce.js\n// module id = 110\n// module chunks = 0","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseSlice.js\n// module id = 112\n// module chunks = 0","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/toFinite.js\n// module id = 166\n// module chunks = 0","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/toInteger.js\n// module id = 167\n// module chunks = 0","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/toNumber.js\n// module id = 168\n// module chunks = 0","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/path-to-regexp/~/isarray/index.js\n// module id = 169\n// module chunks = 0","import _ from 'lodash';\nimport t from 'tcomb';\nimport pathToRegexp from 'path-to-regexp';\n\nimport { Component } from './types';\n\n/**\n * Creates a single route parser given a path (ex /some/:named/:path*)\n * The return exec method returns an object of all named parameters\n *\n * Returned exec() method takes a url string and returns an object with route params\n *\n * @param {Regex} path\n * @returns {Object} with exec() method to match against strings\n */\nfunction routeParser (path) {\n  const keys = [];\n  const re = pathToRegexp(path, keys);\n\n  return {\n    exec (str) {\n      const matches = re.exec(str);\n      if (!matches) return null;\n\n      return _.reduce(_.tail(matches), (obj, match, i) => {\n        if (!match) return obj;\n\n        obj[keys[i].name] = match;\n        return obj;\n      }, {});\n    }\n  };\n}\n\n/**\n * Takes multiple route definitions and returns a single\n * parse function to match against all the definitions\n * Example of a definition: {\n *   SomeRoute: [Component, '/some/:named/:path*']\n * }\n * @param {Object} definitions\n * @returns {Function} parser\n */\nfunction routeMapper (definitions) {\n  const parsers = _.map(definitions, function definitionsToParser (def, name) {\n    const parser = routeParser(def[1]);\n    return function exec (str) {\n      const params = parser.exec(str);\n      if (!params) return null;\n      return { name, params };\n    };\n  });\n\n  return function parser (str) {\n    for (const parse of parsers) {\n      const result = parse(str);\n      if (result) return result;\n    }\n    return null;\n  };\n}\n\n/**\n * Main router function; takes a set of route definitions and\n * returns a relm component which utilizies those routes\n * Example of a definition: {\n *   SomeRoute: [Component, '/some/:named/:path*']\n * }\n * @param {Object} routeDefinitions\n * @returns {Object} component\n */\nexport default function router (routeDefinitions) {\n  if (process.env.NODE_ENV !== 'production') {\n    const Path = t.refinement(t.String, x => _.startsWith('/', x), 'Path');\n\n    const RouteWithoutOptions = t.tuple([Component, Path], '-');\n    const RouteWithOptions = t.tuple([Component, Path, t.Boolean], '-');\n\n    const RouteDefinition = t.union([\n      RouteWithoutOptions,\n      RouteWithOptions\n    ], 'Route');\n\n    RouteDefinition.dispatch = x => (x.length > 2 ? RouteWithOptions : RouteWithoutOptions);\n\n    t.dict(t.String, RouteDefinition, 'Routes')(routeDefinitions);\n  }\n\n  const parseRoute = routeMapper(routeDefinitions);\n\n  function Router (html, params) {\n    const { props, children, components } = params;\n\n    const url = props.url || '';\n    const prefixedUrl = _.startsWith(url, '/') ? url : `/${url}`;\n    const route = parseRoute(prefixedUrl);\n    if (!route) return null;\n\n    const child = components[route.name];\n    const childProps = _.assign(props, route.params);\n\n    return child(childProps, children);\n  }\n\n  Router.components = _.mapValues(routeDefinitions, def => def[0]);\n\n  return Router;\n}\n\nexport const internals = {\n  routeParser,\n  routeMapper,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/router.js","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    isArray = require('./isArray');\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/map.js\n// module id = 78\n// module chunks = 0","var arrayReduce = require('./_arrayReduce'),\n    baseEach = require('./_baseEach'),\n    baseIteratee = require('./_baseIteratee'),\n    baseReduce = require('./_baseReduce'),\n    isArray = require('./isArray');\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3;\n\n  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n}\n\nmodule.exports = reduce;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/reduce.js\n// module id = 79\n// module chunks = 0","var baseClamp = require('./_baseClamp'),\n    baseToString = require('./_baseToString'),\n    toInteger = require('./toInteger'),\n    toString = require('./toString');\n\n/**\n * Checks if `string` starts with the given target string.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {string} [target] The string to search for.\n * @param {number} [position=0] The position to search from.\n * @returns {boolean} Returns `true` if `string` starts with `target`,\n *  else `false`.\n * @example\n *\n * _.startsWith('abc', 'a');\n * // => true\n *\n * _.startsWith('abc', 'b');\n * // => false\n *\n * _.startsWith('abc', 'b', 1);\n * // => true\n */\nfunction startsWith(string, target, position) {\n  string = toString(string);\n  position = baseClamp(toInteger(position), 0, string.length);\n  target = baseToString(target);\n  return string.slice(position, position + target.length) == target;\n}\n\nmodule.exports = startsWith;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/startsWith.js\n// module id = 80\n// module chunks = 0","var baseSlice = require('./_baseSlice');\n\n/**\n * Gets all but the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.tail([1, 2, 3]);\n * // => [2, 3]\n */\nfunction tail(array) {\n  var length = array ? array.length : 0;\n  return length ? baseSlice(array, 1, length) : [];\n}\n\nmodule.exports = tail;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/tail.js\n// module id = 81\n// module chunks = 0","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string} str\n * @return {!Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys)\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/path-to-regexp/index.js\n// module id = 82\n// module chunks = 0","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_arrayMap.js\n// module id = 93\n// module chunks = 0","/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_arrayReduce.js\n// module id = 94\n// module chunks = 0","/**\n * The base implementation of `_.clamp` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\n\nmodule.exports = baseClamp;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseClamp.js\n// module id = 96\n// module chunks = 0"],"sourceRoot":""}